package springMvcApp.dao;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.BatchPreparedStatementSetter;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;
import springMvcApp.models.Person;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

@Component
public class PersonDAO {

    private final JdbcTemplate jdbcTemplate;

    @Autowired
    public PersonDAO(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    //READ CRUD
    public List<Person> index()  {
        //BeanPropertyRowMapper переводит строки из бд в объект через сеттеры
        return jdbcTemplate.query("SELECT * FROM person",new BeanPropertyRowMapper<>(Person.class));
    }
    //READ CRUD
    //Optional<> класс обертка, может существовать , а может и нет
    public Optional<Person> show(String email){
        return jdbcTemplate.query("SELECT * FROM Person WHERE email=?",new Object[]{email},
                new BeanPropertyRowMapper<>(Person.class)).stream().findAny();
    }

    public Person show (int id){
        return jdbcTemplate.query("SELECT * FROM Person WHERE id=?",new Object[]{id},new BeanPropertyRowMapper<>(Person.class)).stream().findAny().orElse(null);
    }
    //CREATE CRUD
    public void save(Person person){
        //для передачи параметров в запрос используется var args,а не массив Object[]
        //id генерируется автоматически - create table Person (id SERIAL)или(id GENERATED BY DEFAULT AS IDENTITY-новый способ) в запросе не указываем id
        jdbcTemplate.update("INSERT INTO Person(name,age,email) VALUES (?,?,?)",
                person.getName(),person.getAge(),person.getEmail());
    }
    //UPDATE CRUD
    public void update(int id,Person updatedPerson){
        jdbcTemplate.update("UPDATE Person SET name=?,age=?,email=?WHERE id=?",
                updatedPerson.getName(),updatedPerson.getAge(),updatedPerson.getEmail(),id);
    }
    //DELETE CRUD
    public void delete(int id){
        jdbcTemplate.update("DELETE FROM Person WHERE id=?",id);
    }

    public List<Person>create1000People(){
        long before = System.currentTimeMillis();
        List<Person>people = new ArrayList<>();
        for (int i=0;i<1000;i++){
            people.add(new Person(i,"Name"+i,30,"test"+i+"@mail.ru"));
        }
        long after = System.currentTimeMillis();
        System.out.println("Time to create 100: "+(after-before));
        return people;
    }
    //multi insert in db
    public void testMultiUpdate(){

        List<Person>people = create1000People();

        long before = System.currentTimeMillis();

        for (Person person:people){
            jdbcTemplate.update("INSERT INTO Person VALUES (?,?,?,?)",person.getId()
            ,person.getName(),person.getAge(),person.getEmail());
        }

        long after = System.currentTimeMillis();
        System.out.println("Time: "+(after-before));
    }
    //batch insert in db
    //@Transactional
    public void testBatchUpdate(){

        List<Person>people = create1000People();

        long before = System.currentTimeMillis();

            jdbcTemplate.batchUpdate("INSERT INTO Person (name,age,email) VALUES (?,?,?)",
                    new BatchPreparedStatementSetter() {
                        @Override
                        public void setValues(PreparedStatement preparedStatement, int i) throws SQLException {

                            preparedStatement.setString(1,people.get(i).getName());
                            preparedStatement.setInt(2,people.get(i).getAge());
                            preparedStatement.setString(3,people.get(i).getEmail());
                        }

                        @Override
                        public int getBatchSize() {
                            return people.size();
                        }
                    });

        long after = System.currentTimeMillis();
        System.out.println("Time: "+(after-before));
    }


}
